/* eslint-disable no-console */
// const crypto = require('node:crypto');
// const fs = require('node:fs');
// const process = require('node:process');

/**
 * Processes SARIF results and creates GitHub issues for findings.
 * @param {{ github: any, context: any }} params
 */
async function processSarifAndCreateIssues({ github, context }) {
  console.log('-------------------------');
  console.log('Processing SARIF results to create GitHub issues...');
  console.log(github, context);

  // const SARIF_PATH = 'results.sarif';
  // const FINGERPRINT_LENGTH = 8;
  // const JSON_INDENT = 2;

  // if (!fs.existsSync(SARIF_PATH)) {
  //   process.stderr.write('No SARIF file found. Clean scan.\n');
  //   return;
  // }
  // const sarif = JSON.parse(fs.readFileSync(SARIF_PATH, 'utf8'));
  // if (!sarif.runs || sarif.runs.length === 0) {
  //   process.stderr.write('No runs found in SARIF file.\n');
  //   return;
  // }
  // const { data: allIssues } = await github.rest.issues.listForRepo({
  //   ...context.repo,
  //   state: 'all',
  //   labels: 'codeql-finding',
  // });
  // /** @type {Array<{repo: any, title: string, body: string, labels: string[]}>} */
  // const issueCreations = [];
  // for (const run of sarif.runs) {
  //   if (!run.results) {
  //     // eslint-disable-next-line no-continue
  //     continue;
  //   }
  //   for (const result of run.results) {
  //     const { ruleId, message, partialFingerprints, locations } = result;
  //     const msg = message.text;
  //     const findingHash = crypto
  //       .createHash('md5')
  //       .update(`${ruleId}|${JSON.stringify(partialFingerprints)}|${msg}`)
  //       .digest('hex')
  //       .substring(0, FINGERPRINT_LENGTH);
  //     const title = `CodeQL Finding: ${ruleId} [${findingHash}]`;
  //     let locationsList = '';
  //     if (locations) {
  //       for (const loc of locations) {
  //         const locFile = loc.physicalLocation.artifactLocation.uri;
  //         const locLine = loc.physicalLocation.region.startLine;
  //         const locMessage = loc.message ? ` - ${loc.message.text}` : '';
  //         locationsList += `- **File:** \`${locFile}\` **Line:** ${locLine}${locMessage}\n`;
  //       }
  //     }
  //     const resultJson = JSON.stringify(result, null, JSON_INDENT);
  //     const body = [
  //       `## ðŸš¨ Security Alert: ${ruleId}`,
  //       `<strong>Message:</strong> ${msg}`,
  //       `<strong>Finding ID:</strong> <code>${findingHash}</code>`,
  //       '---',
  //       '### Vulnerability Locations',
  //       locationsList,
  //       '---',
  //       '<details>',
  //       '<summary>Click to view SARIF finding details</summary>',
  //       '',
  //       '```json',
  //       resultJson,
  //       '```',
  //       '</details>',
  //       '',
  //       '---',
  //       '*This issue was automatically generated by a custom CodeQL workflow.*',
  //     ].join('\n\n');
  //     const existingIssue = allIssues.find(
  //       (/** @type {{title: string, state: string}} */ issue) => issue.title === title,
  //     );
  //     if (existingIssue) {
  //       if (existingIssue.state === 'closed') {
  //         process.stderr.write(
  //           `Issue "${title}" was previously closed. Respecting user decision - not reopening.\n`,
  //         );
  //       } else {
  //         process.stderr.write(
  //           `Issue "${title}" already exists and is open. Skipping.\n`,
  //         );
  //       }
  //     } else {
  //       issueCreations.push({
  //         repo: context.repo,
  //         title,
  //         body,
  //         labels: ['codeql-finding'],
  //       });
  //     }
  //   }
  // }
  // // Batch create issues using Promise.all
  // await Promise.all(
  //   issueCreations.map(async (issue) => {
  //     try {
  //       await github.rest.issues.create(issue);
  //     } catch (err) {
  //       process.stderr.write(`Failed to create issue: ${issue.title}\n${err}\n`);
  //     }
  //   }),
  // );
}

module.exports = processSarifAndCreateIssues;
